策略模式： 策略接口（interface规划相同的方法）->策略实现（继承实现，不同的功能不同的代码）->策略封装(策略实例化，具体使用那个策略)->策略调用

代理模式:  接口定义（被实际使用的地方以及代理类实现）->调度实现，代理实现(代理其实只提供接口 不提供服务) -> 调度

单例... (多线程模式中可能存在拥有相同的两个实例的地方，解决（实例化方法直接返回私有变量，变量为自身类实例），其他方法应该也有)

多例模式：(php有点貌似不怎么好实现 - -) 会定义一个最大能生成多少个实例的私有对象，初始话之前就定义好了 可以按找给定的序号或者自己生成一个随机的序号返回实例

工厂模式：接口定义->接口实现->工厂定义（根据需要实例化谁）-> 调用工厂 （应用：延迟始化，初始化后不释放，工厂中定义一个hashmap存放已实例化的实例就成）

抽象工厂模式： 同上 复杂一点 接口定义与实现大多为抽象类 || 工厂模式：高内聚 低耦合

门面模式：定义接口（后续如果有多封装门面的话，方法顺序可以混乱）-> 接口实现 -> (这里可以加一个门面封装顺序，执行顺序，暴露个接口到外面就可以) 特点:高内聚

适配器模式：系统扩展时使用 （作用：接口转换）

模板方法模式：抽象类定义（方法，暴露的执行方法中要制定顺序）-> 模板实现 -> 客户端实现

建造者模式：（和工厂模式有点相似：建造者模式主要功能是调用顺序安排，基本方法功能已经实现;工厂模式：重点在创建，顺序不是它关心的事情）

桥梁模式：不是很理解。大体分两种角色（业务抽象角色，业务实现角色，扩展在与业务实现角色，以及调用地方的修改）

命令模式：请求方与执行方分开，中间加个调度方接受请求方请求 并调用执行方执行

装饰模式：抽象最核心的对象->核心对象，原始对象，基本接口或抽象类的实现->实现一个抽象类实现接口或抽象方法（必有私有属性指向上一层）-> 具体装饰实现

啼代器模式：

组合模式：结构分解 -> 部分实现 -> 组装
