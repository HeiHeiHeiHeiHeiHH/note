
PHP5.4之后有内置一个服务器（不能用与线上，无需构建本地服务）php -S HOST_IP -t 指定目录

递归： 自己调用自己，自己包含自己   function a( param b) { a(param c);} 属于函数内再次调用自己
      注意：1 递归是函数在过程中或函数里面调用自身
	    2 在使用递归时 必须要有一个明确的递归结束条件，成为递归出口
      两个阶段：1 递推：把复杂的问提的求解推到比原问题简单一些的问题的求解;
		2 回归：当获得最简单的情况后，逐步返回，依次获得复杂的解

迭代： 将输出做输入，再次进行处理。迭代次数越多，细节都越高（A 不停调用B）
 	递归忠一定有迭代，反之不然， 大部分可以相互转换，能用迭代的不用递归（递归效率有点低，浪费空间，并容易造成堆栈的溢出）


高阶函数： 最常见使用策略模式

call_user_func_array(callable $callback,array()) 调用回调，并把一个数组作为参数.
        也可以以对象静态方法作为callback， example : call_user_func_array(array('classname','func'),array(data));



Xdubug  代码调试工具（相比于echo print 等断点， 在不熟悉代码的情况下效率更高）默认端口9000 建议重置
    修改php.ini： [xdebug] xdebug.remote_port = ip_port
	记得xdebug的端口是否可用与重复  phpstrom内置web application端口问题等

依赖管理Composer与packagist
packagist 安装一般为pear(php-pear   使用现在较少)


composer .json文件配置说明  name : "所有者/包名"
			   description : "包描述  通常一句话"
			   keywords : "包作用关键字 利于检索"
       基本信息：	   homepage: "包主页或个人主页"
			   time :"发布时间"
			   license : 决定公开发布的许可证［MIT］
    			   authors : {作者数组，新名，邮箱，主页等信息}


	依赖管理：	  require : {组件对象， 所有者/包名 ： 版本号信息 等}

	开发依赖：	  require-dev: {}  开发环境使用组件  生产环境不需要使用.

 	自动加载：          Vendor/autoload.php  自动加载文件(Vendor外目录运用命名空间可以在这里添加)

			  config : 自定义Vendor目录位置    默认当前目录下

     			  repositories : {package位置、类型等}

			  scripts: 运行脚本  install scripts \ update scripts


                          自动添加包  composer require content 然后update

nowdoc与heredoc区别
  	nowdoc :   $test = <<<'EOD'
			AAAAAA.
			BBBBBBBBB.
			CCCCC.
			$sth DDDDDD.
		   EOD;    $sth不会以变量的形式所解析
	heredoc:   $test = <<<EOD
			    AAAAA.
			    BBBBBBB.
			    CCCC.
			    $sth DDDDD.
			   EOD;   $sth会被解析
	


 	现定义固定长字符串再输出会比直接输出多占用一倍的内存！！！！！！！


使用UTF8编码（未在底层实现怼Unicode的支持）
 	WEB应用从三个方面入手。1 HTML 2 SQL 3 PHP
 	PHP层面的使用：对于字符串操作（有些是不会影响的），如果该函数有mb_*扩展过的用法，使用mb_*。
		      或者脚本开头使用mb_internal_encoding()，然后在对浏览器输出的脚本中使用mb_http_output().
	另外：字符串操作如能指定指定编码集最好指定.

	数据层面：数据库设计时指定编码集为UTF8MB4。  并在链接数据库请求时也使用相同的编码集.

	浏览器层面：脚本输出使用mb_http_output()确保输出格式.
		    html head 标签指定页面编码<meta >中 Content-type charset

复杂语法： {$params}


满二叉树： 每个节点有且仅有两个字节点。


完全二叉树： 深度为K 有N个节点。 当且仅当其每个节点都与深度为K的满二叉树中序号为1至n的节点对应。


冒泡排序：   轮询两个，比较大小，交替位置。

快速排序：   以任一元素作为基准，对比分为两个区域，比他大的与小的，递归的排寻出两个分区。 组合

归并：       分治法  将问题分解， 子问题的解的合并即问题的解。
	    
堆排序：    最大堆与最小堆。 
	    首先：对数据进行依次二叉排 找出最大或最小。  然后进行递归。

选择排序：   不是稳定的排寻算法， 数据大时， 因为可能交换操作的原因，占用较大的CPU。 n小的时候比冒泡快
	    时间复杂度O(n2);

插入排序：   假定有一个子序列已经排序完成。 将后续与之比较，并运行。
 
希尔排序：   首先分组进行插入排序， 在分组插入排序， 最后重组。(d1 => n/2,d2 => d1/2,d3 = d2/2 ...1）


打开文件读的方法：
      1 fopen($file, "r+a")  打开一个文件或url. 返回一个对文件本身的引用
        feof($fp) 参数：文件引用。 判断是否读取到文件的最后。
        fclose($fp)  关闭文件引用 释放资源
        fgets($fp, $font-size)  获取文件中的一行内容， 不会超过font-size的大小。  适用读取文本型文件
	freads($fp,$bytesize)   读取二进制文件， 因二进制文件没有行的概念必须指定$bytesize(max 8Kb)

      2 跳跃访问： fseek($fp, 0 ,$pose);


文件写方法：
	fopen($file, "w+a")
	fwrite($fp,$data);
	fclose($fp);

xml结构
     <?xml version="1.0"  encoding="字符编码" ?>
     有且仅有一个最顶层节点 类似余html中 <html></html>
        中间包含任一标签节点。  注意闭合。
    

grep : 查找文件或命令结果中匹配表达式命中的行结果 。 
     grep -i  忽略表达式大小写的形式
     grep -r/-R  递归的在某个中的所有文件查询  -h 禁止文件路径的显示
     grep -w  返回包含指定表达式的结果。  -c   返回命中的次数   -n 命中目标的所在行数  
	  -v  反转匹配（不匹配）  -l 返回包含匹配式的文件


shell_exec($shell_command)    返回值：命令执行结果。

取地址符&:   php中&符号的含义为一个变量或函数或对象的别名。 当建立别名后不管是unset(别名or原量)都只是删除了他们之间的别名链接。并没有删除原有的地址空间，内容还存在。 在函数中使用别名引用变量， 若在函数内别名值改变， 对应的原量也会改变（毕竟指向同一内存空间）。  此时使用函数是不可在别名位置传递常量。因为只有变量才能被引用。

date()时间格式'Y-m-t'：  返回当月的最后一天。

getopt():  从命令行参数列表中获取选项。 ex: $data = getopt($options,$longopts,$optind)
           $options:  单个字符a-zA-Z0-9: . 参数传递时：-a-zA-Z0-9=value;
	   $longiots: 选项数组。 每个元素会被最为选项字符串。  匹配：--string=value;

array_shift($array):  移出数组$array中的第一个素。 返回第一个元素的值.

array_diff($arr1,$arr2) : 计算数组的差值。  

list($param1, $param2 ...) = array($value1,$value2 ...) 注意list()不是真真意义的函数而是一种语言结构，将数组的至分配至相应的变量中去  

urlencode(): 将中文字符转换为urlencode格式，数字、阿拉伯字符不会被转换

http_build_query():将数组中的键值转换为http请求中的数据请求格式。

array_chunk($array,$size): 将数组分隔为多个数组，数组大小为size



RPC 远程调用服务(Remote Procedure Call Protocol)：成熟框架Thrift、duddo等。（JUMEI：PHP-CLIENT）
   1  本地客服端以本地调用服务的方式调用远程服务。
   2  客服端rpc服务接受到调用后将方法、参数等信息封装成能够进行网络传输的消息体。
   3  找到相对应的服务地址后，将信息加密传输至服务端。
   4  服务端接受消息后解密。
   5  根据解码信息调用server上的本地服务
   6  执行并将结果返回给server
   7  server将结果打包加密发送至消费方
   8  client接受消息解密。
   9  服务方获取最终结果.
     RPC的目标是对2-8的封装。
         难点  1  消息体的序列化与反序列化（加密解密二进制，毕竟网络通信）
               2  明确规范消息数据结构
	       3  通信。  通信模型：BIO，NIO  需都支持.
		  BIO通信方式： 没一个请求添加一个进程，当进程达到上限时，后续请求将会排队等待（同步阻塞？？？？？？？？）
  		  NIO通信方式： 分而治之。尽可能的任务分细，让每个进程都能满载和满效率的使用。
			主要分为：mainReactor线程负责监控server_socket,accept新链接。subReactor负责多路分离已链接的socket（可以单一进程，可以进程池，取决于CPU核数），做后worKer。

   	       4  如何确保客服端所接受的返回信息是自己所需要的结果。
		    1 客服端请求RPC服务是产生一个基于当前socket的唯一uid.
		    2 对于请求结果调用回调函数，存放到全局方法中，根据uid处理
 	            3 对于回调函数中，当前进程试图使用uid获取返回结果，如无则等待。 回调锁？ 什么鬼？
		   

mcpd: redis本地连接池。


聚美RPC服务使用：
	对于业务构建RPC服务： 继承与JMRpcServer类。 建立相应的入口文件。
			     建立AuthClient认证文件夹： 继承JMRpcServerAuthClientUser()验证Secret,设定可以访问的类与方法   规范 filename_classname::methodname/* 。 建立相应的文件与类文件。 写入绑定的方法，给定参数，运行，返回运行结果。


	使用：   根据PHPClient组件中的Config文件。  配置所需调用的rpc服务


对于apt安装软件包：
  apt-cache search packagename 搜索指定名称的软件包
  apt-cache show packagename 获取相关包的相关信息
  apt-get install package  安装软件包
  apt-get install package --reinstall 重新安装
  apt-get -f install 修复安装 -f == --fix-missing
  apt-get remove package 卸载一个已安装的软件包（保留配置文件）
  apt-get check 检查是否有已损坏的依赖
  apt-get remove package --purge 删除包包括配置文件等
  apt-get update 更新源
  sudo apt-get upgrade 更新已安装的包
  apt-get dist-upgrade 升级系统的内核
  apt-get dselect-upgrade 升级方式为dselect
  apt-get build-dep package 安装相关的编译环境
  apt-get source package 下载软件包源代码
  apt-get autoclean  已转已卸的软件备份至硬派
  apt-get clean && autoclean 清理无用的包
  apt-cache depends package 了解使用依赖
  apt-cache rdepends package 查看该包被那些包依赖
  apt-cache dumpavail 打印可用软件包列表
  dpkg -L package 列出软件包中的所以文件
  dpkg -force-all --purge packagename 卸载难以卸载的软件
  dpkg -I package-name-pattern  
  



对于hg版本控制 当没有merge提交至中心代码库时  中心代码库主干分支并没有该次提交的代码记录。
只保存有该次提交的日志记录（感觉只是做了一次快照） 别的分支讲道理获取不到这次的修改集 
想获取：（个人认为） hg log 查看属于该次提交的提交版本号 
		     hg export 版本号 -o 输出至一个文件
		     hg import 文件名  获取修改集 
		     hg rollback && hg st 查看获取的修改 检查是否所需



对于一个入口文件： 基础功能主要在于定义一些常量，项目路径，路由方法，是否开启调试模式等信息 

对于接口类： 一个类可以继承多个接口逗号分隔 使用过程中通过interfaceof判断
所调用的类是否与需对应类有联系

类复用（trait）：单继承语言代码复用机制 开发者能在不同的层次结构中复用同一个类中的
的方法。 使用：采用use关键字   一个类中可使用多个复用类   逗号分隔。
优先级：基类继承的成员会被trait中出入的成员所覆盖。当前类成员覆盖了trait的方法
，而trait则覆盖了被继承的方法。
多个trait存在相同方法冲突的解决：1 可以使用insteadof操作符指定使用那个冲突方法
2 as操作符引入某个方法的别名。


因为nginx服务器在服务器问题是不会输出错误的信息不易调试
   采用PHP自带的模拟服务器 php -S address:port 会报出错误信息与位置.


PHP多进程与多线程只能运行在cli模式下.
  多进程pnctl扩展（unix环境）:  通过fork机制。 pnctl_fork() 从当前位置生成一个子进程。 子进程的堆栈信息从父进程中完全复制的。 所以fork之前的变量信息子进程也不是使用。返回值0 ，-1 ，pid
    0 ： fork成功。产生一个子进程。当需循环fork子进程是子进程结束必须exit()  -1 : fork失败  > 0 : 父进程
    僵尸进程：当子进程退出后，父进程没有及时回收，保留了子进程的执行状态 
    串行：在需要循环fork进程时，一般情况下必须等待子进程功能结束后在进行新的fork。 通过pnctl_wait($status)获取子进程的执行状态(父进程）。
    并行：循环fork进程时。 通过pnctl_waitpid()  并添加参数WNOHANG, 无需等待子进程的返回状态 直接跳过 进行后续fork 达到并行处理。


FLUME：运行的3种模式  
    Exec Source 直接运行 采用unix command的方式组织数据 快速数据完整性不能保证 单是实时性强
    Spooling Dirctory SOurce 监测配置的目录下新增的文件  同样有限制 实时性比较强 但是数据完整 限制：1 拷贝到spool下的文件不可以在编辑 2 不可包含相应的子目录
    Channel方式：MemoryChannel, JDBC Channel ,MemoryRecoverChannel, fileChannel.

    memoryChannel可以实现高速的吞吐，但是无法保证数据的完整性
    MemoryRecoverChannel使用filechannel代替
    filechannel保证数据完整性和一致性，不过吞吐慢与memorychannel
    
    核心概念：
	agent:代理 一个机器只有一个agent 可以有多个sources和sinks
     	Client:生产数据，运行在一个独立的线程
	Source:从client收集数据，传递给channel
 	sink:从channel中收集数据 运行与一个独立的线程
	channel: 连接source和sinks 数据中间缓存
 	Events:可以是日志记录、avro对象等

    将数据推到hdfs时， 在hadoop中重新建立一个新的节点存储
    使用：在conf中编辑想应的agent、channel、sinks信息
      运行：/bin/flume-ng agent --conf ../conf -f /path/conf.conf -n agentname -Dflume.root.logger=INFO,console  最后一项为调试模式

